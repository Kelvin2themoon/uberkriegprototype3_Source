<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_basicCursor</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initiate

//destroy redundent syscom command menues
with obj_path_node instance_destroy();
ds_priority_clear(global.move_order);

//deactivate battle cursor
instance_deactivate_object(obj_battleCursor);


//depth
depth = UI_DEPTH_CURSOR;
//stop animation
image_speed = 0
//set position
//global.posX = x div 24 ;
//global.posY = y div 24 ;


//set alarm to Cursor move speed
alarm[1] = 0;
//view control speed - should be divisable by 24
view_speed = 8;
//view boarder to cursor
view_border = 2*24;

//set origin (for after curswor moves)
moveOriginX = global.posX ;
moveOriginY = global.posY ;


//SET ACTIONABLE UNITS AND TERRAIN ***************************************************

//acting unit
global.acting_unit = obj_map.units[moveOriginX,moveOriginY];
//change unit stat to "active"
global.acting_unit.state = "active";
//change unit depth
global.acting_unit.depth = ACTIVE_UNIT;
//origin
global.origin =obj_map.terrains[moveOriginX,moveOriginY];
//initiate tartget and destination
global.target_unit = noone;
 

//NOTE: set target unit and destination when appropriate

//reset checker tiles
scr_rangeCheck_reset();
//with(obj_checker_tile){ sprite_index = -1;}


//initiate movewstate variable
//move_state_left=0;  (dont remember what this is for
scr_updateLocalMove(global.acting_unit);

//total path move cost variable used to trigger path re-calc
path_total = 0;

//set origin pathority
global.rangeCheck[global.posX,global.posY].pathority = 0;

//clear //clear move order Q
ds_priority_clear(global.move_order);

//create new node to move order
new_path_node = instance_create(x,y,obj_path_node);
new_path_node.pathority_index = path_total;
ds_priority_add(global.move_order,new_path_node,path_total);

//remove acting unit from map array
obj_map.units[moveOriginX,moveOriginY] = 0;

//initiate cambo variable

isActionable = false ;

//clear targetable list

ds_list_clear(global.targetables);

//set unit check
global.unit_check = global.acting_unit;


//boolean to check if move destination was out of bounds so reset on reentry can occure
move_out = false;


















</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///check Radio range for Radio Assist

radioAssistRange = global.acting_unit.radio ;
radioAssist_sprite = spr_radioAssist_gold;
radio_assist_on = true;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///initiate alarm for cursor controls
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///animate
image_index = global.cursorFrameIndex

//set pos
global.posX = x div 24 ;
global.posY = y div 24 ;

//switch Radio assis graphics
if (global.rangeCheck[global.posX, global.posY].sprite_index = spr_rangecheck_bluedk or (global.acting_unit.x div 24 = global.posX and global.acting_unit.y div 24 = global.posY and global.acting_unit.isStanding = false) ) assis_sprite = spr_radioAssist_darkBlue ;
else if (global.rangeCheck[global.posX, global.posY].sprite_index = spr_rangecheck_clear or (global.acting_unit.x div 24 = global.posX and global.acting_unit.y div 24 = global.posY and global.acting_unit.isStanding = true)) assis_sprite = spr_radioAssist_gold ;
else assis_sprite = -1 ;


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Navigation by arrow keys


//      check for key delay on press
if (    keyboard_check_pressed(vk_up   ) ||
        keyboard_check_pressed(vk_down ) ||
        keyboard_check_pressed(vk_left ) ||
        keyboard_check_pressed(vk_right) )
        {
        global.cursorKey_delay = global.cursorKey_startspeed ;
        }
//      reset key delay on release
if (    keyboard_check_released(vk_up   ) ||
        keyboard_check_released(vk_down ) ||
        keyboard_check_released(vk_left ) ||
        keyboard_check_released(vk_right) )
        {
        alarm[1] = 0;
        global.cursorKey_delay = global.cursorKey_startspeed ;
        }
// arrow key actions and juice        
if (alarm[1] = -1 )
    {
    switch(keyboard_key)
        {
        case(vk_nokey):
            alarm[1] = 0;
            global.cursorkey_delay = global.cursorKey_startspeed ;
            break;
        
        case vk_up :
            if ( global.posY &gt; 0 ){ 
                y = y  - 24 ; 
                newpos_x = global.posX +0;
                newpos_y = global.posY -1;
                path_total += scr_check_move_cost(global.acting_unit,obj_map.terrains[newpos_x,newpos_y]);
                if global.rangeCheck[newpos_x,newpos_y].pathority = -1 moveout = true;
                
                //if within max-range
                if (global.rangeCheck[newpos_x,newpos_y].move_cost != -1 ){
                    global.rangeCheck[newpos_x,newpos_y].pathority = path_total;
                    //add new node to move order
                    new_path_node = instance_create(newpos_x*24,newpos_y*24,obj_path_node);
                    new_path_node.pathority_index = path_total;
                    ds_priority_add(global.move_order,new_path_node,path_total);
                    scr_draw_move_path();
                
                    //if max range reached
                    if( (path_total &gt; global.acting_unit.move_points or path_total &gt; global.acting_unit.fuel) or move_out){
                        //destroy all nodes
                        with(obj_checker_tile) pathority = -1;
                        //creat new path
                        scr_find_path( global.rangeCheck[newpos_x,newpos_y]);
                        }
                     move_out = false;   
                    }
                }
            scr_cursorKey_juice(1,global.cursorKey_sfx);
            break;
        
        case vk_down :
            if ( global.posY &lt; global.mapH - 1 ){
                y = y  + 24 ;
                newpos_x = global.posX +0;
                newpos_y = global.posY +1;
                path_total += scr_check_move_cost(global.acting_unit,obj_map.terrains[newpos_x,newpos_y]);
                if global.rangeCheck[newpos_x,newpos_y].pathority = -1 moveout = true;
               
               //if within max-range
                if (global.rangeCheck[newpos_x,newpos_y].move_cost != -1 ){
                    global.rangeCheck[newpos_x,newpos_y].pathority = path_total;
                    //add new node to move order
                    new_path_node = instance_create(newpos_x*24,newpos_y*24,obj_path_node);
                    new_path_node.pathority_index = path_total;
                    ds_priority_add(global.move_order,new_path_node,path_total);
                    scr_draw_move_path();
                
                    //if max range reached
                    if( (path_total &gt; global.acting_unit.move_points or path_total &gt; global.acting_unit.fuel) or move_out){
                        //destroy all nodes
                        with(obj_checker_tile) pathority = -1;
                        //creat new path
                        scr_find_path( global.rangeCheck[newpos_x,newpos_y]);
                        }
                    move_out = false;
                    }
                }
            scr_cursorKey_juice(1,global.cursorKey_sfx);
            break;

        
        case vk_left :
            if ( global.posX &gt; 0 ){
                x = x  - 24 ;
                newpos_x = global.posX -1;
                newpos_y = global.posY +0;
                path_total += scr_check_move_cost(global.acting_unit,obj_map.terrains[newpos_x,newpos_y]);
                if global.rangeCheck[newpos_x,newpos_y].pathority = -1 moveout = true;
                
                //if within max-range
                if (global.rangeCheck[newpos_x,newpos_y].move_cost != -1 ){
                    global.rangeCheck[newpos_x,newpos_y].pathority = path_total;
                    //add new node to move order
                    new_path_node = instance_create(newpos_x*24,newpos_y*24,obj_path_node);
                    new_path_node.pathority_index = path_total;
                    ds_priority_add(global.move_order,new_path_node,path_total);
                    scr_draw_move_path();
                
                    //if max range reached
                   if( (path_total &gt; global.acting_unit.move_points or path_total &gt; global.acting_unit.fuel) or move_out){
                        //destroy all nodes
                        with(obj_checker_tile) pathority = -1;
                        //creat new path
                        scr_find_path( global.rangeCheck[newpos_x,newpos_y]);
                        }
                    move_our = false;
                    }
                }
            scr_cursorKey_juice(1,global.cursorKey_sfx);
            break;
       
                    
        case vk_right :
            if ( global.posX &lt; global.mapW - 1 ){
                x = x  + 24 ;
                newpos_x = global.posX +1;
                newpos_y = global.posY +0;
                path_total += scr_check_move_cost(global.acting_unit,obj_map.terrains[newpos_x,newpos_y]);
                if global.rangeCheck[newpos_x,newpos_y].pathority = -1 moveout = true;
                
                //if within max-range
                if (global.rangeCheck[newpos_x,newpos_y].move_cost != -1 ){
                    global.rangeCheck[newpos_x,newpos_y].pathority = path_total;
                    //add new node to move order
                    new_path_node = instance_create(newpos_x*24,newpos_y*24,obj_path_node);
                    new_path_node.pathority_index = path_total;
                    ds_priority_add(global.move_order,new_path_node,path_total);
                    scr_draw_move_path();
                
                    //if max range reached (re calculate path)
                    if( (path_total &gt; global.acting_unit.move_points or path_total &gt; global.acting_unit.fuel) or move_out){
                        //destroy all nodes
                        with(obj_checker_tile) pathority = -1;
                        //creat new path
                        scr_find_path( global.rangeCheck[newpos_x,newpos_y]);
                        }
                    move_our = false;
                    }
                }
           
            //juice
            scr_cursorKey_juice(1,global.cursorKey_sfx);
            break;
            
        }
        
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// view control


// check for boarders and move 

if ( view_xview[0] &gt; x - view_border and global.canScroll_x) view_xview[0] -= view_speed;

if ( view_xview[0] + view_wport[0] &lt; x + view_border + 24 and global.canScroll_x) view_xview[0] += view_speed;

if ( view_yview[0] &gt; y - view_border and global.canScroll_y) view_yview[0] -= view_speed;

if ( view_yview[0] + view_hport[0] &lt; y + view_border+24 and global.canScroll_y) view_yview[0] += view_speed;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///confirm to open command menu



global.target_unit  = obj_map.units[global.posX,global.posY];
global.destination  = obj_map.terrains[global.posX,global.posY];

//check: key press confirm
if ( global.ip_A_pressed )
    {
    //reset actionable variables (just in case)
    global.capture      = false;
    global.engage       = false;
    global.join         = false;
    global.attach       = false;
    global.supply       = false;
    global.load         = false;
    global.drop_A       = false;
    global.drop_B       = false;
    global.infiltrate   = false; 
    global.hide         = false;
    global.appear       = false;
    global.disrupt      = false;
    global.wait         = true ; // wait is on by default
    
    var isEmpty = true; // destination is default empty
    
    //check if unit has moved: for indirect fire checks
    if (ds_priority_size(global.move_order) &lt;2) global.acting_unit_moved = false;
    else global.acting_unit_moved = true;
    
    
    
    //check range
    if (global.rangeCheck[global.posX,global.posY].move_cost = -1) 
    { 
    //out of range, do nothing, switch off wait
    global.wait = false;
    } 
    
    
    else // check: destination is in range, check for appropriate commands and turn them on
    {
        if (global.target_unit != 0 ) //check:  a unit occupies the destination
        {
            // destination is occupied
            isEmpty = false; 
            global.wait = false; 
            
            // target is ally ( therefor is also visible ) valid ations: join, attach, load
            if ( global.target_unit.team = global.P_Turn.team ) 
            {
                // Join: check target unit is of the same type and hp is less than 10
                if ( global.acting_unit.name = global.target_unit.name  and global.target_unit.hp &lt; 10) global.join = true;
                
                //turn join off if unit can load
                if  (global.acting_unit.canLoadInfantry &gt; 0 )
                    {
                    if(global.acting_unit.load_A != 0 or global.acting_unit.load_B != 0) global.join = false;
                    }
                if  (global.target_unit.canLoadInfantry &gt; 0 )
                    {
                    if(global.target_unit.load_A != 0 or global.target_unit.load_B != 0) global.join = false;
                    }
                
                // Attach: check acting unit is  officer and target unit is not of command rank
                if ( global.acting_unit.name = "Officer" and !global.target_unit.isCommander ) global.attach = true;
                
                //Load: check if target is APC and if acting unit is infantry
                if (    global.target_unit.name = "A.P.C." 
                        and 
                        ( 
                        global.acting_unit.name="Light Infantry" 
                     or global.acting_unit.name="Heavy Infantry" 
                     or global.acting_unit.name="Long Gun"
                        ) 
                   )
                {
                
                // there is room in the APC
                if (global.target_unit.load_A = 0 or global.target_unit.load_B = 0) global.load = true;
                
                }    
                
            }
            
            //target is enemy
            else if ( global.target_unit.team != global.P_Turn.team ) 
            {
                show_debug_message("enemy unit check pass");
                if (global.target_unit.isVisible) //destination is vivibally occupied by an enemy unit
                {
                    // do nothing
                    // this will eventually be a short-cut for engage and disrupt
                }
                else
                {
                    show_debug_message("invisible enemy unit check pass");
                    //teat destination as if it is empty
                    isEmpty = true;
                    global.wait = true; //turn wait back on
                } 
            }
            //target unit is on the same team but does not belong to the currrent player ( team, but not ally )
            else if ( global.target_unit.team = global.P_Turn.team ) 
            {
                //do nothing
                //don't thing there will be dooin' of anything here, though...
            }
            
        }
        
        // destination appears empty
        if ( isEmpty )
        {
        
        show_debug_message("empty check passed");

        
        //check if unit is covert op. and turn on appear or dissapppear
        
        if (global.acting_unit.name = "Covert Op."){
            if (global.acting_unit.isHidden){
                //activate appear
                global.appear = true;
                }
            else{
                global.hide = true;
                }
            }
        
        //check for property
        if(object_is_ancestor(obj_map.terrains[global.posX, global.posY].object_index, obj_property) 
            and obj_map.terrains[global.posX, global.posY].ownership != global.P_Turn.number
            and global.acting_unit.canCapture )
        {
            global.capture = true ;
        }
        
        // For APC:
        if (global.acting_unit.name = "A.P.C.")
        {
            // Check for adjacent ally unit for Supply action
            if (scr_check_units_in_range(global.posX, global.posY, 1, 1, true))
            {
                global.supply = true;
            }
            // Check if units can be dropped
            var num_units_adjacent = ds_list_size(global.targetables);
            if ( global.acting_unit.load_A != 0 and num_units_adjacent &lt; 4 )
            {
                global.drop_A = true;
            }
            if ( global.acting_unit.load_B != 0 and num_units_adjacent &lt; 4 )
            {
                global.drop_B = true;
            }
        }
        
        //add engage if visible enemy units are in range 
        //check primary weaopn
        if ( (global.acting_unit.havePrimaryWeapon and global.acting_unit.ammo &gt; 0) or (global.acting_unit.name = "Covert Op." and global.alt_Disrupt )) //---------------------------------
            {
                show_debug_message("Primary Weapon Check");
                //exception: land cruiser
                if (global.acting_unit.max_range = 1 or global.acting_unit.name = "Land Cruiser")
                
                    {
                    //max range is 1 or is land cuiser, process as direct attack (can move and 
                            if (scr_check_units_in_range( global.posX, global.posY, global.acting_unit.min_range, global.acting_unit.max_range, false))
                            {
                            
                                global.engage = true;
                                global.engage_type = 1;
                                if global.acting_unit.name = "Covert Op." global.engage_type = 2;
                            
                            }
                    
                        }
                //otherwise process as indirect (target location = origin)
                else 
                    {
                        
                        if (global.acting_unit_moved = false )
                            {
                                if ( scr_check_units_in_range( global.posX, global.posY, global.acting_unit.min_range, global.acting_unit.max_range, false)and global.acting_unit.name != "Covert Op.")
                                    {
                                    
                                        global.engage = true;
                                        global.engage_type = 1;
                                    
                                    }
                                else if (scr_check_units_in_range( global.posX, global.posY, global.acting_unit.min_range, global.acting_unit.max_range, false and global.alt_Disrupt ))
                                    {
                                    
                                        if global.acting_unit.ammo &gt; 0 global.disrupt = true ;
                                    
                                    }
                            }
                        
                        }
        
            }
        //check secondary weapon
        else if (global.acting_unit.haveSecondaryWeapon){
        show_debug_message("secondary weapon check");
            if ( scr_check_units_in_range( global.posX, global.posY, 1 , 1 , false)){
                global.engage = true;
                global.engage_type = 2;
                //if disrupt is avaliable and basic type
                if (global.acting_unit.canDisrupt and global.acting_unit.ammo &gt;0 and !global.alt_Disrupt) {
                    global.disrupt = true;
                }
            }
        }
        //exception: covert Op
        if (global.acting_unit.name = "Covert Op." and global.alt_Disrupt)
            
            {
            
                if ( scr_check_units_in_range( global.posX, global.posY, 1 , 1 , false))
                    
                    {
                    
                        global.engage = true;
                        global.engage_type = 2;
                    
                    }
        
            
            }
        
        }
    
    
    
    }
    
    //if items exsist, create syscom_command
    if(global.capture   or
    global.engage       or
    global.join         or
    global.attach       or
    global.supply       or
    global.load         or
    global.drop_A       or
    global.drop_B       or
    global.infiltrate   or
    global.hide         or
    global.appear       or
    global.disrupt      or
    global.wait)
    {
        
        
        //clear all checker graphics ( no sprite)
        with(obj_checker_tile) sprite_index = -1;
        //change sprite back at destination
        global.rangeCheck[global.posX,global.posY].sprite_index = spr_rangecheck_clear
        
        //deactivate move cursor object
        instance_deactivate_object(obj_moveCursor);
        //create command menu    
        instance_create(x+24,y,obj_syscom_command); 
    }
            
        
    

}
        
    





/*old code for check syntax

else{
    //if a unit [ally] occupies target location, destination is invalid    
     if (global.target_unit != 0){
        //if target unit is an ally
        if (global.target_unit.ownership = global.P_Turn.number){
            //disable: wait
            global.wait = false;
        
        //check for load
        if ( global.target_unit.name = "A.P.C." and (global.acting_unit.name="Light Infantry" or (global.acting_unit.name="Heavy Infantry" or (global.acting_unit.name="Long Gun")))){
            if (global.target_unit.load_A = 0 or global.target_unit.load_B = 0) global.load = true;
            }
        
        //if target and acting are the same type : turn on join comman
        if(global.target_unit.name = global.acting_unit.name and obj_map.units[x div 24, y div 24].hp &lt; 10) global.join = true; 
        //if acting is officer and target is not commander
        if ( global.acting_unit.object_index = obj_unit_Officer and global.target_unit.isCommander = false){
            //add attach command
            global.attach = true;
            }
        if (global.attach or global.join or global.load){
            global.wait = false; 
            }
            
        }
        

        
        }
    //else target is in range &amp; no unit visibly occupies the location    
    else{
        show_debug_message("empty check passed");

        
        //check if unit is vovert op. and turn on appear or dissapppear
        
        if (global.acting_unit.name = "Covert Op."){
            if (global.acting_unit.isHidden){
                //activate appear
                global.appear = true;
                }
            else{
                global.hide = true;
                }
            }
        
        //check for property
        if(object_is_ancestor(obj_map.terrains[global.posX, global.posY].object_index, obj_property) 
            and obj_map.terrains[global.posX, global.posY].ownership != global.P_Turn.number
            and global.acting_unit.canCapture )
        {
            global.capture = true ;
        }
        
        // For APC:
        if (global.acting_unit.name = "A.P.C.")
        {
            // Check for adjacent ally unit for Supply action
            if (scr_check_units_in_range(global.posX, global.posY, 1, 1, true))
            {
                global.supply = true;
            }
            // Check if units can be dropped
            var num_units_adjacent = ds_list_size(global.targetables);
            if ( global.acting_unit.load_A != 0 and num_units_adjacent &lt; 4 )
            {
                global.drop_A = true;
            }
            if ( global.acting_unit.load_B != 0 and num_units_adjacent &lt; 4 )
            {
                global.drop_B = true;
            }
        }
        
        //add engage if visible enemy units are in range 
        //check primary weaopn
        if ( global.acting_unit.havePrimaryWeapon and global.acting_unit.ammo &gt; 0 )
        {
            show_debug_message("Primary Weapon Check");
        
            if (global.acting_unit.max_range = 1 or global.acting_unit.name = "Land Cruiser"){
                //max range is 1 or is land cuiser, process as direct attack (can move and 
                if (scr_check_units_in_range( global.posX, global.posY, global.acting_unit.min_range, global.acting_unit.max_range, false)){
                        global.engage = true;
                        global.engage_type = 1;
                        }
                    }
                //otherwise process as indirect (target location = origin)
                else {
                    if (global.acting_unit_moved = false){
                        if ( scr_check_units_in_range( global.posX, global.posY, global.acting_unit.min_range, global.acting_unit.max_range, false)){
                            global.engage = true;
                            global.engage_type = 1;
                            }
                        }
                    
                    }
        
            }
        //check secondary weapon
        else if (global.acting_unit.haveSecondaryWeapon){
        show_debug_message("secondary weapon check");
            if ( scr_check_units_in_range( global.posX, global.posY, 1 , 1 , false)){
                global.engage = true;
                global.engage_type = 2;
                //if disrupt is avaliable
                if (global.acting_unit.canDisrupt and global.acting_unit.ammo &gt;0) {
                    global.disrupt = true;
                }
            }
        }
    }
    //if items exsist, create syscom_command
    if(global.capture   or
    global.engage       or
    global.join         or
    global.attach       or
    global.supply       or
    global.load         or
    global.drop_A       or
    global.drop_B       or
    global.infiltrate   or
    global.hide         or
    global.appear       or
    global.disrupt      or
    global.wait){
        
        
        //clear all checker graphics ( no sprite)
        with(obj_checker_tile) sprite_index = -1;
        //change sprite back at destination
        global.rangeCheck[global.posX,global.posY].sprite_index = spr_rangecheck_clear
        
        //deactivate move cursor object
        instance_deactivate_object(obj_moveCursor);
        //create command menu    
        instance_create(x+24,y,obj_syscom_command); 
        }
            
        
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///set miniwin intel

global.terrain_check = obj_map.terrains[global.posX,global.posY];
global.unit_check = obj_map.units[global.posX,global.posY];
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///set values to draw Radio Assist


radioAssistRange = global.acting_unit.radio ;
radioAssist_sprite = spr_radioAssist_gold;
radio_assist_on = false;


if (scr_inBound(global.posX,global.posY))
    {
    if (global.rangeCheck[global.posX,global.posY].sprite_index != -1 or (global.posX = moveOriginX and global.posY = moveOriginY ))
        {
        radioAssistRange = scr_getUnitRadioRange(global.acting_unit,obj_map.terrains[global.posX,global.posY]);
        if(global.rangeCheck[global.posX,global.posY].sprite_index = spr_rangecheck_clear or (global.posX = moveOriginX and global.posY = moveOriginY)) radioAssist_sprite = spr_radioAssist_gold;
        else radioAssist_sprite = spr_radioAssist_darkBlue;
        radio_assist_on = true;
        //check if position is occupied by a unit
        if(obj_map.units[global.posX,global.posY] != 0)
            {
            //chang range to target unit
            radioAssistRange = scr_getUnitRadioRange(obj_map.units[global.posX,global.posY],obj_map.terrains[global.posX,global.posY]);
            //if target unit is field officer
            if( obj_map.units[global.posX,global.posY].name = "Officer")
                {
                radioAssist_sprite = spr_radioAssist_gold;
                }
            }
        }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///press "B"

if  (keyboard_check_pressed(global.keyCANCEL))
    {
    //clear move datea
    scr_rangeCheck_reset();
    //clear move order array
    ds_priority_clear(global.move_order);
    //destroy path nodes
    with(obj_path_node) instance_destroy();
   
    //place active unit back in array
    obj_map.units[global.acting_unit.x div 24,global.acting_unit.y div 24] = global.acting_unit
    global.acting_unit.state = "idle";
    scr_setUnitDepth(global.acting_unit);
    
     

    //reset path Q
    ds_priority_clear(global.move_order);
    
    //place acting unit back into array
 
    //reset global vunit command variables to default
    global.acting_unit  = 0;    //empty
    global.target_unit  = 0;    //empty
    global.action_order = "wait"; //default to wait
    
    //reactivate main phaze YI
    instance_activate_object(obj_battleCursor);
    instance_activate_object(obj_miniwin);
    //destroy move cursor
    with (obj_moveCursor){instance_destroy();}
    
    
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Debug

//draw_text(12, 240, string(global.acting_unit.team) + "/" + string(global.acting_unit.ownership));


/*

draw_text(12,300, "movecost: " + string( global.rangeCheck[x div 24, y div 24].move_cost) + "/" +string(global.acting_unit.move_points));
draw_text(12,313, "terrain cost: " + string(scr_check_move_cost(global.acting_unit,obj_map.terrains[x div 24, y div 24])));


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw radio assist

if radio_assist_on
    {
    scr_draw_radioAssist(global.posX,global.posY,radioAssistRange,radioAssist_sprite);
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw self
draw_self();
if (global.acting_unit.name = "Land Cruiser" and global.acting_unit.ammo &gt; 0) draw_sprite(spr_CruiserPlusCursor,0,x,y);


if (obj_map.units[global.posX,global.posY] !=0 and global.rangeCheck[global.posX,global.posY].sprite_index =spr_rangecheck_clear){
    if ((global.cursorFrame = 2 or global.cursorFrame = 1) and obj_map.units[global.posX,global.posY].team = global.P_Turn.team ){
        //join
        if (obj_map.units[global.posX,global.posY].hp &lt; 10 and obj_map.units[global.posX,global.posY].name = global.acting_unit.name) draw_sprite( spr_basicCursor_Icons,4,x,y); 
        //attach
        if ( obj_map.units[global.posX,global.posY].isCommander = false and global.acting_unit.canAttach) draw_sprite(spr_basicCursor_Icons,3,x,y);
        //Load
        if ( obj_map.units[global.posX,global.posY].name = "A.P.C."){
            if (global.acting_unit.name = "long Gun" or global.acting_unit.name = "Light Infantry" or global.acting_unit.name = "Heavy Infantry") draw_sprite( spr_basicCursor_Icons,2,x,y);
            }                
        }
    }
    
//draw_text(x, y-24, "move cost"); 

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
