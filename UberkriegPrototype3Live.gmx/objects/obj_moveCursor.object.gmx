<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_basicCursor</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initiate

//destroy redundent syscom command menues
with obj_path_node instance_destroy();
ds_priority_clear(global.move_order);

//deactivate battle cursor
instance_deactivate_object(obj_battleCursor);


//depth
depth = UI_DEPTH_CURSOR;
//stop animation
image_speed = 0
//set position
//global.posX = x div 24 ;
//global.posY = y div 24 ;


//set alarm to Cursor move speed
alarm[1] = 0;
//view control speed - should be divisable by 24
view_speed = 8;
//view boarder to cursor
view_border = 4*24;

//set origin (for after curswor moves)
moveOriginX = global.posX ;
moveOriginY = global.posY ;


//SET ACTIONABLE UNITS AND TERRAIN ***************************************************

//acting unit
global.acting_unit = obj_map.units[moveOriginX,moveOriginY];
//change unit stat to "active"
global.acting_unit.state = "active";
//change unit depth
global.acting_unit.depth = ACTIVE_UNIT;
//origin
global.origin =obj_map.terrains[moveOriginX,moveOriginY];
//initiate tartget and destination
global.target_unit = noone;
 

//NOTE: set target unit and destination when appropriate

//reset checker tiles
scr_rangeCheck_reset();
//with(obj_checker_tile){ sprite_index = -1;}


//initiate movewstate variable
//move_state_left=0;  (dont remember what this is for
scr_updateLocalMove(global.acting_unit);

//total path move cost variable used to trigger path re-calc
path_total = 0;

//set origin pathority
global.rangeCheck[global.posX,global.posY].pathority = 0;

//clear //clear move order Q
ds_priority_clear(global.move_order);

//create new node to move order
new_path_node = instance_create(x,y,obj_path_node);
new_path_node.pathority_index = path_total;
ds_priority_add(global.move_order,new_path_node,path_total);

//remove acting unit from map array
obj_map.units[moveOriginX,moveOriginY] = 0;

//initiate cambo variable

isActionable = false ;

//clear targetable list

ds_list_clear(global.targetables);

//set unit check
global.unit_check = global.acting_unit;





















</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///initiate alarm for cursor controls
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///animate
image_index = global.cursorFrameIndex

//set pos
global.posX = x div 24 ;
global.posY = y div 24 ;


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Navigation by arrow keys


//      check for key delay on press
if (    keyboard_check_pressed(vk_up   ) ||
        keyboard_check_pressed(vk_down ) ||
        keyboard_check_pressed(vk_left ) ||
        keyboard_check_pressed(vk_right) )
        {
        global.cursorKey_delay = global.cursorKey_startspeed ;
        }
//      reset key delay on release
if (    keyboard_check_released(vk_up   ) ||
        keyboard_check_released(vk_down ) ||
        keyboard_check_released(vk_left ) ||
        keyboard_check_released(vk_right) )
        {
        alarm[1] = 0;
        global.cursorKey_delay = global.cursorKey_startspeed ;
        }
// arrow key actions and juice        
if (alarm[1] = -1 )
    {
    switch(keyboard_key)
        {
        case(vk_nokey):
            alarm[1] = 0;
            global.cursorkey_delay = global.cursorKey_startspeed ;
            break;
        
        case vk_up :
            if ( global.posY &gt; 0 ){ 
                y = y  - 24 ; 
                newpos_x = global.posX +0;
                newpos_y = global.posY -1;
                path_total += scr_check_move_cost(global.acting_unit,obj_map.terrains[newpos_x,newpos_y]);
                
                //if within max-range
                if (global.rangeCheck[newpos_x,newpos_y].move_cost != -1 ){
                    global.rangeCheck[newpos_x,newpos_y].pathority = path_total;
                    //add new node to move order
                    new_path_node = instance_create(newpos_x*24,newpos_y*24,obj_path_node);
                    new_path_node.pathority_index = path_total;
                    ds_priority_add(global.move_order,new_path_node,path_total);
                    scr_draw_move_path();
                
                    //if max range reached
                    if( path_total &gt; global.acting_unit.move_points){
                        //destroy all nodes
                        with(obj_checker_tile) pathority = -1;
                        //creat new path
                        scr_find_path( global.rangeCheck[newpos_x,newpos_y]);
                        }
                    }
                }
            scr_cursorKey_juice(1,global.cursorKey_sfx);
            break;
        
        case vk_down :
            if ( global.posY &lt; global.mapH - 1 ){
                y = y  + 24 ;
                newpos_x = global.posX +0;
                newpos_y = global.posY +1;
                path_total += scr_check_move_cost(global.acting_unit,obj_map.terrains[newpos_x,newpos_y]);
               
               //if within max-range
                if (global.rangeCheck[newpos_x,newpos_y].move_cost != -1 ){
                    global.rangeCheck[newpos_x,newpos_y].pathority = path_total;
                    //add new node to move order
                    new_path_node = instance_create(newpos_x*24,newpos_y*24,obj_path_node);
                    new_path_node.pathority_index = path_total;
                    ds_priority_add(global.move_order,new_path_node,path_total);
                    scr_draw_move_path();
                
                    //if max range reached
                    if( path_total &gt; global.acting_unit.move_points){
                        //destroy all nodes
                        with(obj_checker_tile) pathority = -1;
                        //creat new path
                        scr_find_path( global.rangeCheck[newpos_x,newpos_y]);
                        }
                    }
                }
            scr_cursorKey_juice(1,global.cursorKey_sfx);
            break;

        
        case vk_left :
            if ( global.posX &gt; 0 ){
                x = x  - 24 ;
                newpos_x = global.posX -1;
                newpos_y = global.posY +0;
                path_total += scr_check_move_cost(global.acting_unit,obj_map.terrains[newpos_x,newpos_y]);
                
                //if within max-range
                if (global.rangeCheck[newpos_x,newpos_y].move_cost != -1 ){
                    global.rangeCheck[newpos_x,newpos_y].pathority = path_total;
                    //add new node to move order
                    new_path_node = instance_create(newpos_x*24,newpos_y*24,obj_path_node);
                    new_path_node.pathority_index = path_total;
                    ds_priority_add(global.move_order,new_path_node,path_total);
                    scr_draw_move_path();
                
                    //if max range reached
                    if( path_total &gt; global.acting_unit.move_points){
                        //destroy all nodes
                        with(obj_checker_tile) pathority = -1;
                        //creat new path
                        scr_find_path( global.rangeCheck[newpos_x,newpos_y]);
                        }
                    }
                }
            scr_cursorKey_juice(1,global.cursorKey_sfx);
            break;
       
                    
        case vk_right :
            if ( global.posX &lt; global.mapW - 1 ){
                x = x  + 24 ;
                newpos_x = global.posX +1;
                newpos_y = global.posY +0;
                path_total += scr_check_move_cost(global.acting_unit,obj_map.terrains[newpos_x,newpos_y]);
                
                //if within max-range
                if (global.rangeCheck[newpos_x,newpos_y].move_cost != -1 ){
                    global.rangeCheck[newpos_x,newpos_y].pathority = path_total;
                    //add new node to move order
                    new_path_node = instance_create(newpos_x*24,newpos_y*24,obj_path_node);
                    new_path_node.pathority_index = path_total;
                    ds_priority_add(global.move_order,new_path_node,path_total);
                    scr_draw_move_path();
                
                    //if max range reached
                    if( path_total &gt; global.acting_unit.move_points){
                        //destroy all nodes
                        with(obj_checker_tile) pathority = -1;
                        //creat new path
                        scr_find_path( global.rangeCheck[newpos_x,newpos_y]);
                        }
                    }
                }
           
            //juice
            scr_cursorKey_juice(1,global.cursorKey_sfx);
            break;
        }
        
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// view control


// check for boarders and move 

if ( view_xview[0] &gt; x - view_border and global.canScroll_x) view_xview[0] -= view_speed;

if ( view_xview[0] + view_wport[0] &lt; x + view_border + 24 and global.canScroll_x) view_xview[0] += view_speed;

if ( view_yview[0] &gt; y - view_border and global.canScroll_y) view_yview[0] -= view_speed;

if ( view_yview[0] + view_hport[0] &lt; y + view_border+24 and global.canScroll_y) view_yview[0] += view_speed;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///press "B"

if  (keyboard_check_pressed(global.keyCANCEL))
    {
    //clear move datea
    scr_rangeCheck_reset();
    //clear move order array
    ds_priority_clear(global.move_order);
    //destroy path nodes
    with(obj_path_node) instance_destroy();
   
    //place active unit back in array
    obj_map.units[global.acting_unit.x div 24,global.acting_unit.y div 24] = global.acting_unit
    global.acting_unit.state = "idle";
    scr_setUnitDepth(global.acting_unit);
    
     

    //reset path Q
    ds_priority_clear(global.move_order);
    
    //place acting unit back into array
 
    //reset global vunit command variables to default
    global.acting_unit  = 0;    //empty
    global.target_unit  = 0;    //empty
    global.action_order = "wait"; //default to wait
    
    //reactivate main phaze YI
    instance_activate_object(obj_battleCursor);
    instance_activate_object(obj_miniwin);
    //destroy move cursor
    with (obj_moveCursor){instance_destroy();}
    
    
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///confirm to open command menu



global.target_unit  = obj_map.units[global.posX,global.posY];
global.destination  = obj_map.terrains[global.posX,global.posY];

//check: key press confirm
if ( keyboard_check_pressed( global.keyCONFIRM) )
    {
    //reset actionable variables (just in case)
    global.capture      = false;
    global.engage       = false;
    global.join         = false;
    global.attach       = false;
    global.supply       = false;
    global.load         = false;
    global.drop_A       = false;
    global.drop_B       = false;
    global.infiltrate   = false; 
    global.hide         = false;
    global.appear       = false;
    global.disrupt      = false;
    global.wait         = true ; // wait is on by default
    
    var isEmpty = true; // destination is default empty
    
    //check if unit has moved: for indirect fire checks
    if (ds_priority_size(global.move_order) &lt;2) global.acting_unit_moved = false;
    else global.acting_unit_moved = true;
    
    
    
    //check range
    if (global.rangeCheck[global.posX,global.posY].move_cost = -1) 
    { 
    //out of range, do nothing, switch off wait
    global.wait = false;
    } 
    
    
    else // check: destination is in range, check for appropriate commands and turn them on
    {
        if (global.target_unit != 0 ) //check:  a unit occupies the destination
        {
            // destination is occupied
            isEmpty = false; 
            global.wait = false; 
            
            // target is ally ( therefor is also visible ) valid ations: join, attach, load
            if ( global.target_unit.ownership = global.P_Turn.number ) 
            {
                // Join: check target unit is of the same type and hp is less than 10
                if ( global.acting_unit.name = global.target_unit  and global.target_unit.hp &lt; 10) global.join = true;
               
                // Attach: check acting unit is  officer and target unit is not of command rank
                if ( global.acting_unit.name = "Officer" and !global.target_unit.isCommander ) global.attach = true;
                
                //Load: check if target is APC and if acting unit is infantry
                if (    global.target_unit.name = "A.P.C." 
                        and 
                        ( 
                        global.acting_unit.name="Light Infantry" 
                     or global.acting_unit.name="Heavy Infantry" 
                     or global.acting_unit.name="Long Gun"
                        ) 
                   )
                {
                
                // there is room in the APC
                if (global.target_unit.load_A = 0 or global.target_unit.load_B = 0) global.load = true;
                
                }    
                
            }
            
            //target is enemy
            else if ( global.target_unit.team != global.P_Turn.team ) 
            {
                if (global.target_unit.isVisible) //destination is vivibally occupied by an enemy unit
                {
                    // do nothing
                    // this will eventually be a short-cut for engage and disrupt
                }
                else
                {
                    //teat destination as if it is empty
                    isEmpty = true;
                    global.wait = true; //turn wait back on
                } 
            }
            //target unit is on the same team but does not belong to the currrent player ( team, but not ally )
            else if ( global.target_unit.team = global.P_Turn.team ) 
            {
                //do nothing
                //don't thing there will be dooin' of anything here, though...
            }
            
        }
        
        // destination appears empty
        else if ( isEmpty )
        {
        
        show_debug_message("empty check passed");

        
        //check if unit is vovert op. and turn on appear or dissapppear
        
        if (global.acting_unit.name = "Covert Op."){
            if (global.acting_unit.isHidden){
                //activate appear
                global.appear = true;
                }
            else{
                global.hide = true;
                }
            }
        
        //check for property
        if(object_is_ancestor(obj_map.terrains[global.posX, global.posY].object_index, obj_property) 
            and obj_map.terrains[global.posX, global.posY].ownership != global.P_Turn.number
            and global.acting_unit.canCapture )
        {
            global.capture = true ;
        }
        
        // For APC:
        if (global.acting_unit.name = "A.P.C.")
        {
            // Check for adjacent ally unit for Supply action
            if (scr_check_units_in_range(global.posX, global.posY, 1, 1, true))
            {
                global.supply = true;
            }
            // Check if units can be dropped
            var num_units_adjacent = ds_list_size(global.targetables);
            if ( global.acting_unit.load_A != 0 and num_units_adjacent &lt; 4 )
            {
                global.drop_A = true;
            }
            if ( global.acting_unit.load_B != 0 and num_units_adjacent &lt; 4 )
            {
                global.drop_B = true;
            }
        }
        
        //add engage if visible enemy units are in range 
        //check primary weaopn
        if ( global.acting_unit.havePrimaryWeapon and global.acting_unit.ammo &gt; 0 )
        {
            show_debug_message("Primary Weapon Check");
        
            if (global.acting_unit.max_range = 1 or global.acting_unit.name = "Land Cruiser"){
                //max range is 1 or is land cuiser, process as direct attack (can move and 
                if (scr_check_units_in_range( global.posX, global.posY, global.acting_unit.min_range, global.acting_unit.max_range, false)){
                        global.engage = true;
                        global.engage_type = 1;
                        }
                    }
                //otherwise process as indirect (target location = origin)
                else {
                    if (global.acting_unit_moved = false){
                        if ( scr_check_units_in_range( global.posX, global.posY, global.acting_unit.min_range, global.acting_unit.max_range, false)){
                            global.engage = true;
                            global.engage_type = 1;
                            }
                        }
                    
                    }
        
            }
        //check secondary weapon
        else if (global.acting_unit.haveSecondaryWeapon){
        show_debug_message("secondary weapon check");
            if ( scr_check_units_in_range( global.posX, global.posY, 1 , 1 , false)){
                global.engage = true;
                global.engage_type = 2;
                //if disrupt is avaliable
                if (global.acting_unit.canDisrupt and global.acting_unit.ammo &gt;0) {
                    global.disrupt = true;
                }
            }
        }
        
        }
    
    
    
    }
    
    //if items exsist, create syscom_command
    if(global.capture   or
    global.engage       or
    global.join         or
    global.attach       or
    global.supply       or
    global.load         or
    global.drop_A       or
    global.drop_B       or
    global.infiltrate   or
    global.hide         or
    global.appear       or
    global.disrupt      or
    global.wait)
    {
        
        
        //clear all checker graphics ( no sprite)
        with(obj_checker_tile) sprite_index = -1;
        //change sprite back at destination
        global.rangeCheck[global.posX,global.posY].sprite_index = spr_rangecheck_clear
        
        //deactivate move cursor object
        instance_deactivate_object(obj_moveCursor);
        //create command menu    
        instance_create(x+24,y,obj_syscom_command); 
    }
            
        
    

}
        
    





/*old code for check syntax

else{
    //if a unit [ally] occupies target location, destination is invalid    
     if (global.target_unit != 0){
        //if target unit is an ally
        if (global.target_unit.ownership = global.P_Turn.number){
            //disable: wait
            global.wait = false;
        
        //check for load
        if ( global.target_unit.name = "A.P.C." and (global.acting_unit.name="Light Infantry" or (global.acting_unit.name="Heavy Infantry" or (global.acting_unit.name="Long Gun")))){
            if (global.target_unit.load_A = 0 or global.target_unit.load_B = 0) global.load = true;
            }
        
        //if target and acting are the same type : turn on join comman
        if(global.target_unit.name = global.acting_unit.name and obj_map.units[x div 24, y div 24].hp &lt; 10) global.join = true; 
        //if acting is officer and target is not commander
        if ( global.acting_unit.object_index = obj_unit_Officer and global.target_unit.isCommander = false){
            //add attach command
            global.attach = true;
            }
        if (global.attach or global.join or global.load){
            global.wait = false; 
            }
            
        }
        

        
        }
    //else target is in range &amp; no unit visibly occupies the location    
    else{
        show_debug_message("empty check passed");

        
        //check if unit is vovert op. and turn on appear or dissapppear
        
        if (global.acting_unit.name = "Covert Op."){
            if (global.acting_unit.isHidden){
                //activate appear
                global.appear = true;
                }
            else{
                global.hide = true;
                }
            }
        
        //check for property
        if(object_is_ancestor(obj_map.terrains[global.posX, global.posY].object_index, obj_property) 
            and obj_map.terrains[global.posX, global.posY].ownership != global.P_Turn.number
            and global.acting_unit.canCapture )
        {
            global.capture = true ;
        }
        
        // For APC:
        if (global.acting_unit.name = "A.P.C.")
        {
            // Check for adjacent ally unit for Supply action
            if (scr_check_units_in_range(global.posX, global.posY, 1, 1, true))
            {
                global.supply = true;
            }
            // Check if units can be dropped
            var num_units_adjacent = ds_list_size(global.targetables);
            if ( global.acting_unit.load_A != 0 and num_units_adjacent &lt; 4 )
            {
                global.drop_A = true;
            }
            if ( global.acting_unit.load_B != 0 and num_units_adjacent &lt; 4 )
            {
                global.drop_B = true;
            }
        }
        
        //add engage if visible enemy units are in range 
        //check primary weaopn
        if ( global.acting_unit.havePrimaryWeapon and global.acting_unit.ammo &gt; 0 )
        {
            show_debug_message("Primary Weapon Check");
        
            if (global.acting_unit.max_range = 1 or global.acting_unit.name = "Land Cruiser"){
                //max range is 1 or is land cuiser, process as direct attack (can move and 
                if (scr_check_units_in_range( global.posX, global.posY, global.acting_unit.min_range, global.acting_unit.max_range, false)){
                        global.engage = true;
                        global.engage_type = 1;
                        }
                    }
                //otherwise process as indirect (target location = origin)
                else {
                    if (global.acting_unit_moved = false){
                        if ( scr_check_units_in_range( global.posX, global.posY, global.acting_unit.min_range, global.acting_unit.max_range, false)){
                            global.engage = true;
                            global.engage_type = 1;
                            }
                        }
                    
                    }
        
            }
        //check secondary weapon
        else if (global.acting_unit.haveSecondaryWeapon){
        show_debug_message("secondary weapon check");
            if ( scr_check_units_in_range( global.posX, global.posY, 1 , 1 , false)){
                global.engage = true;
                global.engage_type = 2;
                //if disrupt is avaliable
                if (global.acting_unit.canDisrupt and global.acting_unit.ammo &gt;0) {
                    global.disrupt = true;
                }
            }
        }
    }
    //if items exsist, create syscom_command
    if(global.capture   or
    global.engage       or
    global.join         or
    global.attach       or
    global.supply       or
    global.load         or
    global.drop_A       or
    global.drop_B       or
    global.infiltrate   or
    global.hide         or
    global.appear       or
    global.disrupt      or
    global.wait){
        
        
        //clear all checker graphics ( no sprite)
        with(obj_checker_tile) sprite_index = -1;
        //change sprite back at destination
        global.rangeCheck[global.posX,global.posY].sprite_index = spr_rangecheck_clear
        
        //deactivate move cursor object
        instance_deactivate_object(obj_moveCursor);
        //create command menu    
        instance_create(x+24,y,obj_syscom_command); 
        }
            
        
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///set miniwin intel

global.terrain_check = obj_map.terrains[global.posX,global.posY];
global.unit_check = obj_map.units[global.posX,global.posY];
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Debug

/*

draw_text(12,300, "movecost: " + string( global.rangeCheck[x div 24, y div 24].move_cost) + "/" +string(global.acting_unit.move_points));
draw_text(12,313, "terrain cost: " + string(scr_check_move_cost(global.acting_unit,obj_map.terrains[x div 24, y div 24])));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();
if (global.acting_unit.name = "Land Cruiser" and global.acting_unit.ammo &gt; 0) draw_sprite(spr_CruiserPlusCursor,0,x,y);


if (obj_map.units[global.posX,global.posY] !=0 and global.rangeCheck[global.posX,global.posY].sprite_index =spr_rangecheck_clear){
    if ((global.cursorFrame = 2 or global.cursorFrame = 1) and obj_map.units[global.posX,global.posY].ownership = global.P_Turn.number ){
        //join
        if (obj_map.units[global.posX,global.posY].hp &lt; 10 and obj_map.units[global.posX,global.posY].name = global.acting_unit.name) draw_sprite( spr_basicCursor_Icons,4,x,y); 
        //attach
        if ( obj_map.units[global.posX,global.posY].isCommander = false and global.acting_unit.canAttach) draw_sprite(spr_basicCursor_Icons,3,x,y);
        //Load
        if ( obj_map.units[global.posX,global.posY].name = "A.P.C."){
            if (global.acting_unit.name = "long Gun" or global.acting_unit.name = "Light Infantry" or global.acting_unit.name = "Heavy Infantry") draw_sprite( spr_basicCursor_Icons,2,x,y);
            }                
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
