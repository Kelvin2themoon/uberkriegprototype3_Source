<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_basicCursor</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initiate

//destroy redundent syscom command menues
with obj_path_node instance_destroy();
ds_priority_clear(global.move_order);

//deactivate battle cursor
instance_deactivate_object(obj_battleCursor);


//depth
depth = UI_DEPTH_CURSOR;
//stop animation
image_speed = 0
//set position
//global.posX = x div 24 ;
//global.posY = y div 24 ;


//set alarm to Cursor move speed
alarm[1] = 0;
//view control speed - should be divisable by 24
view_speed = 8;
//view boarder to cursor
view_border = 2*24;

//set origin (for after curswor moves)
moveOriginX = global.posX ;
moveOriginY = global.posY ;


//SET ACTIONABLE UNITS AND TERRAIN ***************************************************

//acting unit
global.acting_unit = obj_map.units[moveOriginX,moveOriginY];
//change unit stat to "active"
global.acting_unit.state = "active";
//change unit depth
global.acting_unit.depth = ACTIVE_UNIT;
//origin
global.origin = obj_map.terrains[moveOriginX,moveOriginY];
//initiate tartget and destination
global.target_unit = noone;




//NOTE: set target unit and destination when appropriate

//reset checker tiles
scr_rangeCheck_reset();
//with(obj_checker_tile){ sprite_index = -1;}


//initiate movewstate variable
//move_state_left=0;  (dont remember what this is for
scr_updateLocalMove(global.acting_unit);

//total path move cost variable used to trigger path re-calc
path_total = 0;

//set origin pathority
global.rangeCheck[global.posX,global.posY].pathority = 0;

//clear //clear move order Q
ds_priority_clear(global.move_order);

//create new node to move order
new_path_node = instance_create(x,y,obj_path_node);
new_path_node.pathority_index = path_total;
ds_priority_add(global.move_order,new_path_node,path_total);

//remove acting unit from map array
obj_map.units[moveOriginX,moveOriginY] = 0;

//initiate cambo variable

isActionable = false ;

//clear targetable list

ds_list_clear(global.targetables);

//set unit check
global.unit_check = global.acting_unit;


//boolean to check if move destination was out of bounds so reset on reentry can occure
move_out = false;

//set maximum move
path_max = global.acting_unit.move_points + global.P_Turn.CO.D2D_Mov[global.acting_unit.unit_index];
//apply CO modifyers
if global.P_Turn.CO.COP_on  path_max += global.P_Turn.CO.COP_Mov[global.acting_unit.unit_index];
if global.P_Turn.CO.SCOP_on  path_max += global.P_Turn.CO.SCOP_Mov[global.acting_unit.unit_index];


















</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///mouse control vars initiate

//mouse positions
pointer_pos_x = mouse_x div 24 ;
pointer_pos_Y = mouse_y div 24 ;

//vhevk last location to calculate custom move path
last_pos_x = moveOriginX ;
last_pos_y = moveOriginY ;


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///check Radio range for Radio Assist

radioAssistRange = global.acting_unit.radio ;
radioAssist_sprite = spr_radioAssist_gold;
radio_assist_on = true;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///apply CO range FX for move and shoot cursor
fire_range = global.acting_unit.max_range
fire_range += global.P_Turn.CO.D2D_Rng[global.acting_unit.unit_index];
if ( global.P_Turn.CO.COP_on ) fire_range += global.P_Turn.CO.COP_Rng[global.acting_unit.unit_index];
if ( global.P_Turn.CO.SCOP_on ) fire_range += global.P_Turn.CO.SCOP_Rng[global.acting_unit.unit_index];

//minrange
min_fire_range = global.acting_unit.min_range;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///check if any unit has been lost radio contact
scr_rangeCheck_reset();
with (obj_unit) wasStanding = isStanding;
scr_updateStanding_global();
//update radio boarder
scr_globalRadioCheck();
scr_update_radioBoarder();
scr_rangeCheck_reset();
scr_updateLocalMove(global.acting_unit);


global.acting_unit.isStanding= true;



with (obj_unit)
    {
    if (wasStanding and !isStanding and id != global.acting_unit.id) instance_create(x,y, obj_event_lost);
    } 
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///initiate alarm for cursor controls
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///animate
image_index = global.cursorFrameIndex

//set pos
global.posX = x div 24 ;
global.posY = y div 24 ;

//switch Radio assis graphics
if (global.rangeCheck[global.posX, global.posY].sprite_index = spr_rangecheck_bluedk or (global.acting_unit.x div 24 = global.posX and global.acting_unit.y div 24 = global.posY and global.acting_unit.isStanding = false) ) assis_sprite = spr_radioAssist_darkBlue ;
else if (global.rangeCheck[global.posX, global.posY].sprite_index = spr_rangecheck_clear or (global.acting_unit.x div 24 = global.posX and global.acting_unit.y div 24 = global.posY and global.acting_unit.isStanding = true)) assis_sprite = spr_radioAssist_gold ;
else assis_sprite = -1 ;


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// view control


// check for boarders and move 

if ( view_xview[0] &gt; x  and global.canScroll_x) view_xview[0] -= view_speed;

if ( view_xview[0] + view_wport[0] &lt; x +  + 24 and global.canScroll_x) view_xview[0] += view_speed;

if ( view_yview[0] &gt; y  and global.canScroll_y) view_yview[0] -= view_speed;

if ( view_yview[0] + view_hport[0] &lt; y +24 and global.canScroll_y) view_yview[0] += view_speed;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// *Navigation by arrow keys Disabled

/*
//      check for key delay on press
if (    keyboard_check_pressed(vk_up   ) ||
        keyboard_check_pressed(vk_down ) ||
        keyboard_check_pressed(vk_left ) ||
        keyboard_check_pressed(vk_right) )
        {
        global.cursorKey_delay = global.cursorKey_startspeed ;
        }
//      reset key delay on release
if (    keyboard_check_released(vk_up   ) ||
        keyboard_check_released(vk_down ) ||
        keyboard_check_released(vk_left ) ||
        keyboard_check_released(vk_right) )
        {
        alarm[1] = 0;
        global.cursorKey_delay = global.cursorKey_startspeed ;
        }
// arrow key actions and juice        
if (alarm[1] = -1 )
    {
    switch(keyboard_key)
        {
        case(vk_nokey):
            alarm[1] = 0;
            global.cursorkey_delay = global.cursorKey_startspeed ;
            break;
        
        case vk_up :
            if ( global.posY &gt; 0 ){ 
                y = y  - 24 ; 
                newpos_x = global.posX +0;
                newpos_y = global.posY -1;
                path_total += scr_check_move_cost(global.acting_unit,obj_map.terrains[newpos_x,newpos_y]);
                if global.rangeCheck[newpos_x,newpos_y].pathority = -1 moveout = true;
                
                //if within max-range
                if (global.rangeCheck[newpos_x,newpos_y].move_cost != -1 ){
                    global.rangeCheck[newpos_x,newpos_y].pathority = path_total;
                    //add new node to move order
                    new_path_node = instance_create(newpos_x*24,newpos_y*24,obj_path_node);
                    new_path_node.pathority_index = path_total;
                    ds_priority_add(global.move_order,new_path_node,path_total);
                    scr_draw_move_path();
                
                    //if max range reached
                    if( (path_total &gt; global.acting_unit.move_points + global.P_Turn.CO.D2D_Mov[global.acting_unit.unit_index] or path_total &gt; global.acting_unit.fuel) or move_out){
                        //destroy all nodes
                        with(obj_checker_tile) pathority = -1;
                        //creat new path
                        scr_find_path( global.rangeCheck[newpos_x,newpos_y]);
                        }
                     move_out = false;   
                    }
                }
            scr_cursorKey_juice(1,global.cursorKey_sfx);
            break;
        
        case vk_down :
            if ( global.posY &lt; global.mapH - 1 ){
                y = y  + 24 ;
                newpos_x = global.posX +0;
                newpos_y = global.posY +1;
                path_total += scr_check_move_cost(global.acting_unit,obj_map.terrains[newpos_x,newpos_y]);
                if global.rangeCheck[newpos_x,newpos_y].pathority = -1 moveout = true;
               
               //if within max-range
                if (global.rangeCheck[newpos_x,newpos_y].move_cost != -1 ){
                    global.rangeCheck[newpos_x,newpos_y].pathority = path_total;
                    //add new node to move order
                    new_path_node = instance_create(newpos_x*24,newpos_y*24,obj_path_node);
                    new_path_node.pathority_index = path_total;
                    ds_priority_add(global.move_order,new_path_node,path_total);
                    scr_draw_move_path();
                
                    //if max range reached
                    if( (path_total &gt; global.acting_unit.move_points + global.P_Turn.CO.D2D_Mov[global.acting_unit.unit_index] or path_total &gt; global.acting_unit.fuel) or move_out){
                        //destroy all nodes
                        with(obj_checker_tile) pathority = -1;
                        //creat new path
                        scr_find_path( global.rangeCheck[newpos_x,newpos_y]);
                        }
                    move_out = false;
                    }
                }
            scr_cursorKey_juice(1,global.cursorKey_sfx);
            break;

        
        case vk_left :
            if ( global.posX &gt; 0 ){
                x = x  - 24 ;
                newpos_x = global.posX -1;
                newpos_y = global.posY +0;
                path_total += scr_check_move_cost(global.acting_unit,obj_map.terrains[newpos_x,newpos_y]);
                if global.rangeCheck[newpos_x,newpos_y].pathority = -1 moveout = true;
                
                //if within max-range
                if (global.rangeCheck[newpos_x,newpos_y].move_cost != -1 ){
                    global.rangeCheck[newpos_x,newpos_y].pathority = path_total;
                    //add new node to move order
                    new_path_node = instance_create(newpos_x*24,newpos_y*24,obj_path_node);
                    new_path_node.pathority_index = path_total;
                    ds_priority_add(global.move_order,new_path_node,path_total);
                    scr_draw_move_path();
                
                    //if max range reached
                   if( (path_total &gt; global.acting_unit.move_points + global.P_Turn.CO.D2D_Mov[global.acting_unit.unit_index] or path_total &gt; global.acting_unit.fuel) or move_out){
                        //destroy all nodes
                        with(obj_checker_tile) pathority = -1;
                        //creat new path
                        scr_find_path( global.rangeCheck[newpos_x,newpos_y]);
                        }
                    move_our = false;
                    }
                }
            scr_cursorKey_juice(1,global.cursorKey_sfx);
            break;
       
                    
        case vk_right :
            if ( global.posX &lt; global.mapW - 1 ){
                x = x  + 24 ;
                newpos_x = global.posX +1;
                newpos_y = global.posY +0;
                path_total += scr_check_move_cost(global.acting_unit,obj_map.terrains[newpos_x,newpos_y]);
                if global.rangeCheck[newpos_x,newpos_y].pathority = -1 moveout = true;
                
                //if within max-range
                if (global.rangeCheck[newpos_x,newpos_y].move_cost != -1 ){
                    global.rangeCheck[newpos_x,newpos_y].pathority = path_total;
                    //add new node to move order
                    new_path_node = instance_create(newpos_x*24,newpos_y*24,obj_path_node);
                    new_path_node.pathority_index = path_total;
                    ds_priority_add(global.move_order,new_path_node,path_total);
                    scr_draw_move_path();
                
                    //if max range reached (re calculate path)
                    if( (path_total &gt; global.acting_unit.move_points + global.P_Turn.CO.D2D_Mov[global.acting_unit.unit_index] or path_total &gt; global.acting_unit.fuel) or move_out){
                        //destroy all nodes
                        with(obj_checker_tile) pathority = -1;
                        //creat new path
                        scr_find_path( global.rangeCheck[newpos_x,newpos_y]);
                        }
                    move_our = false;
                    }
                }
           
            //juice
            scr_cursorKey_juice(1,global.cursorKey_sfx);
            break;
            
        }
        
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///navigate by mouse

//update mouse location
//set new mouse co-ordinates from position
mouse_pos_x = mouse_x div 24;
mouse_pos_y = mouse_y div 24;

if (scr_inBound(mouse_pos_x,mouse_pos_y)){
        //check if position has changed
        if ( mouse_pos_x != last_pos_x  or mouse_pos_y != last_pos_y){

                //update new co-ordinates
                global.posX = mouse_pos_x;
                global.posY = mouse_pos_y;
                //move curosr
                x =  global.posX*24; //&lt;--new positions
                y =  global.posY*24; //&lt;--new positions
                
                //juice
                scr_cursorKey_juice(1,global.cursorKey_sfx);
                
               //if new positioni is adjacent and move points are sufficient
               if   (   abs(mouse_pos_x - last_pos_x) + abs(mouse_pos_y - last_pos_y) = 1
                        and path_total + scr_check_move_cost(global.acting_unit,obj_map.terrains[mouse_pos_x,mouse_pos_y]) &lt;= global.acting_unit.move_points
                        and path_total + scr_check_move_cost(global.acting_unit,obj_map.terrains[mouse_pos_x,mouse_pos_y]) &lt;= global.acting_unit.fuel
                        and !move_out
                        and global.rangeCheck[mouse_pos_x,mouse_pos_y].move_cost != -1){
                        
                            //increase path cost
                            path_total += scr_check_move_cost(global.acting_unit,obj_map.terrains[mouse_pos_x,mouse_pos_y]);
                            //add new node
                            new_path_node = instance_create(mouse_pos_x*24,mouse_pos_y*24,obj_path_node);
                            new_path_node.pathority_index = path_total;
                            ds_priority_add(global.move_order,new_path_node,path_total);
                            scr_draw_move_path();
                            
                            //update last positions
                            last_pos_x = mouse_pos_x;
                            last_pos_y = mouse_pos_y;
                            }
                        
                // position is not adjacent but within valid move range
                else if ( global.rangeCheck[mouse_pos_x,mouse_pos_y].move_cost != -1){ 
                    //switch back in
                    move_out = false
                    //auto-detect path
                    scr_find_path( global.rangeCheck[mouse_pos_x,mouse_pos_y]);
                    //update last positions
                    last_pos_x = mouse_pos_x;
                    last_pos_y = mouse_pos_y;
                    }
                    
                //out of move range
                else if ( global.rangeCheck[mouse_pos_x,mouse_pos_y].move_cost = -1){
                    //reset paths
                    with(obj_path_node) instance_destroy();
                    //switch on out of bounds
                    move_out = true;
                    //update last positions
                    last_pos_x = mouse_pos_x;
                    last_pos_y = mouse_pos_y;
                    }
            }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///set miniwin intel

global.terrain_check = obj_map.terrains[global.posX,global.posY];
global.unit_check = obj_map.units[global.posX,global.posY];
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///set values to draw Radio Assist


radioAssistRange = global.acting_unit.radio ;
radioAssist_sprite = spr_radioAssist_bronze;
radio_assist_on = false;


if (scr_inBound(global.posX,global.posY))
    {
    if (global.rangeCheck[global.posX,global.posY].sprite_index != -1 or (global.posX = moveOriginX and global.posY = moveOriginY ))
        {
        radioAssistRange = scr_getUnitRadioRange(global.acting_unit,obj_map.terrains[global.posX,global.posY]);
        if(global.rangeCheck[global.posX,global.posY].sprite_index = spr_rangecheck_clear or (global.posX = moveOriginX and global.posY = moveOriginY)) radioAssist_sprite = spr_radioAssist_bronze;
        else radioAssist_sprite = spr_radioAssist_darkBlue;
        radio_assist_on = true;
        //check if position is occupied by a unit
        if(obj_map.units[global.posX,global.posY] != 0)
            {
            //chang range to target unit
             if ( obj_map.units[global.posX,global.posY].ownership = global.P_Turn.number)   radioAssistRange = scr_getUnitRadioRange(obj_map.units[global.posX,global.posY],obj_map.terrains[global.posX,global.posY]);
            //if target unit is field officer
            if ( obj_map.units[global.posX,global.posY].name = "Officer")
                {
                radioAssist_sprite = spr_radioAssist_bronze;
                }
            }
        }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///press "B"

if  (keyboard_check_pressed(global.keyCANCEL) or mouse_check_button_pressed(mb_right) )
    {
    //clear move datea
    scr_rangeCheck_reset();
    //clear move order array
    ds_priority_clear(global.move_order);
    //destroy path nodes
    with(obj_path_node) instance_destroy();
   
    //place active unit back in array
    obj_map.units[global.acting_unit.x div 24,global.acting_unit.y div 24] = global.acting_unit
    global.acting_unit.state = "idle";
    scr_setUnitDepth(global.acting_unit);
    
     

    //reset path Q
    ds_priority_clear(global.move_order);
    
    //place acting unit back into array
 
    //reset global vunit command variables to default
    global.acting_unit  = 0;    //empty
    global.target_unit  = 0;    //empty
    global.action_order = "wait"; //default to wait
    
    //reactivate main phaze YI
    instance_activate_object(obj_battleCursor);
    instance_activate_object(obj_miniwin);
    //destroy move cursor
    with (obj_moveCursorMouse){instance_destroy();}
    
    //reset standing
    scr_updateStanding_global();
    //update Radio Boarder
    scr_globalRadioCheck();
    scr_update_radioBoarder();
    scr_rangeCheck_reset();
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///confirm to open command menu



global.target_unit  = obj_map.units[global.posX,global.posY];
global.destination  = obj_map.terrains[global.posX,global.posY];

//check: key press confirm
if( (mouse_check_button_pressed(mb_left) and !global.mousetype2) or (mouse_check_button_released(mb_left) and global.mousetype2))
    {
    //reset actionable variables (just in case)
    global.capture      = false;
    global.engage       = false;
    global.join         = false;
    global.attach       = false;
    global.supply       = false;
    global.load         = false;
    global.drop_A       = false;
    global.drop_B       = false;
    global.infiltrate   = false; 
    global.hide         = false;
    global.appear       = false;
    global.disrupt      = false;
    global.wait         = true ; // wait is on by default
    
    
    //special CO commands
    global.smoke        = false;

    //destination is default empty
    var isEmpty = true; 
    
    //check if unit has moved: for indirect fire checks
    if (ds_priority_size(global.move_order) &lt;2) global.acting_unit_moved = false;
    else global.acting_unit_moved = true;

    //check range
    if(global.rangeCheck[global.posX,global.posY].move_cost = -1) 
        { 
        //out of range, do nothing, switch off wait
        global.wait = false;
        //exit move action (delet self and reactivate relevent elements)
        //clear move datea
    scr_rangeCheck_reset();
    //clear move order array
    ds_priority_clear(global.move_order);
    //destroy path nodes
    with(obj_path_node) instance_destroy();
   
    //place active unit back in array
    obj_map.units[global.acting_unit.x div 24,global.acting_unit.y div 24] = global.acting_unit
    global.acting_unit.state = "idle";
    scr_setUnitDepth(global.acting_unit);
    
     

    //reset path Q
    ds_priority_clear(global.move_order);
    
    //place acting unit back into array
 
    //reset global vunit command variables to default
    global.acting_unit  = 0;    //empty
    global.target_unit  = 0;    //empty
    global.action_order = "wait"; //default to wait
    
    //reactivate main phaze YI
    instance_activate_object(obj_battleCursor);
    instance_activate_object(obj_miniwin);
    //destroy move cursor
    with (obj_moveCursorMouse){instance_destroy();}
    
    //reset standing
    scr_updateStanding_global();
    //update Radio Boarder
    scr_globalRadioCheck();
    scr_update_radioBoarder();
    scr_rangeCheck_reset();
        
        } 
    
    // check: destination is in range, check for appropriate commands and turn them on
    else
        {
//******check:  a unit occupies the destination
        if (global.target_unit != 0) {
            // destination is occupied
            isEmpty = false; 
            global.wait = false; 
            
            // target is ally ( therefor is also visible ) valid ations: join, attach, load
            if ( global.target_unit.team = global.P_Turn.team ) {
                // Join: check target unit is of the same type and hp is less than 10
                if ( global.acting_unit.name = global.target_unit.name  and global.target_unit.hp &lt; 10 and !global.acting_unit.dummy and !global.target_unit.dummy) global.join = true;
                //turn join off one either unit is can Load and has units loaded
                if  (global.acting_unit.canLoadInfantry &gt; 0 ) if(global.acting_unit.load_A != 0 or global.acting_unit.load_B != 0 ) global.join = false;
                if  (global.target_unit.canLoadInfantry &gt; 0 ) if(global.target_unit.load_A != 0 or global.target_unit.load_B != 0 ) global.join = false;
                // Attach: check acting unit is  officer and target unit is not of command rank
                if ( global.acting_unit.name = "Officer" and !global.target_unit.isCommander and !global.acting_unit.dummy and !global.target_unit.dummy and !global.P_Turn.CO.D2D_CannotAttach) global.attach = true;
                
                //Load: check if target is APC and if acting unit is infantry
                if( global.target_unit.canLoadInfantry
                    and !global.target_unit.dummy
                    and ( 
                        global.acting_unit.name="Light Infantry" 
                     or global.acting_unit.name="Heavy Infantry" 
                     or global.acting_unit.name="Long Gun"
                        ) 
                  )
                    {
                    // there is room in the APC
                    if (global.target_unit.load_A = 0 or global.target_unit.load_B = 0 and !global.target_unit.dummy) global.load = true;
                    }    
                }
            
            //target is enemy
            else if ( global.target_unit.team != global.P_Turn.team) 
                {
                //debug
                //show_debug_message("enemy unit check pass");
                
                //if destination is visibally occupied by an enemy unit
                if (global.target_unit.isVisible) 
                    {
                    // do nothing
                    // this will eventually be a short-cut for engage and disrupt********************************************************************************************************
                    //hey i thought about this, Im a clever boy
                    }
                else
                    {
                    //show_debug_message("invisible enemy unit check pass");
                    //teat destination as if it is empty
                    isEmpty = true;
                    global.wait = true; //turn wait back on
                    }   
                }
                
                
            //target unit is on the same team but does not belong to the currrent player ( team, but not ally )
            else if ( global.target_unit.team = global.P_Turn.team and !global.acting_unit.dummy and !global.target_unit.dummy) 
                {
                //do nothing
                //don't thing there will be dooin' of anything here, though...
                }    
            }
        
//NEW MAJOR CHECK destination appears empty
        if ( isEmpty )
            {
            show_debug_message("empty check passed");
                           
            //check if unit is covert op. and turn on appear or dissapppear (check for infiltrate
            if (global.acting_unit.name = "Covert Op." and !global.acting_unit.dummy)
                {
                //check if the actiing unit is hidden
                if (global.acting_unit.isHidden) global.appear = true;
                else global.hide = true;
                
                //check for infiltrate (enemy proptery adjacent)
                if (scr_checkInfiltrateTargets( global.posX, global.posY )) global.infiltrate = true ;
                
                
                }
                
            //check for property and turn on Capture
            if( object_is_ancestor(obj_map.terrains[global.posX, global.posY].object_index, obj_property) 
            and obj_map.terrains[global.posX, global.posY].ownership != global.P_Turn.number
            and global.acting_unit.canCapture 
            and !global.acting_unit.dummy)
                {
                global.capture = true ;
                }
            
            //check for supply action
            if (global.acting_unit.canSupply and !global.acting_unit.dummy)
                {
                // Check for adjacent ally unit for Supply action
                if (scr_check_units_in_range(global.posX, global.posY, 1, 1, true)) global.supply = true;
                } 
                
            //check Load action
            if( global.acting_unit.canLoadInfantry)
                {
                // Check if units can be dropped
                var num_units_adjacent = ds_list_size(global.targetables);
                //check for and switch  on drap A
                if ( global.acting_unit.load_A != 0 and num_units_adjacent &lt; 4 ) global.drop_A = true;
                //check for and switch  on drap B
                if ( global.acting_unit.load_B != 0 and num_units_adjacent &lt; 4 ) global.drop_B = true;
                }
            
            //check for disrupt
            if( global.acting_unit.canDisrupt and global.acting_unit.ammo &gt; 0 and !global.acting_unit.dummy)
                {
                // check enemy units are in range unit in range
                if( scr_check_units_in_range( global.posX, global.posY, global.acting_unit.min_range, global.acting_unit.max_range, false) )
                    {
                    //check if can Move fire
                    if(global.acting_unit.canMoveFire)    global.disrupt = true;
                    //check indirect fire only
                    else if ( !global.acting_unit_moved ) global.disrupt = true;
                    }
                }
                
            //check for secondary weapon attack type (Direct only)  Note: this will also activate primary weapon types if they are direct fire
            if(global.acting_unit.haveSecondaryWeapon and global.acting_unit.canMoveFire  and scr_check_units_in_range(global.posX,global.posY,1,1,false)and !global.acting_unit.dummy) global.engage = true;
            
            //check and process primary weapons and overide engage type to primary 
            if (global.acting_unit.havePrimaryWeapon and global.acting_unit.ammo &gt; 0 and !global.acting_unit.dummy)
                {
                //apply CO range FX
                fire_range = global.acting_unit.max_range
                fire_range += global.P_Turn.CO.D2D_Rng[global.acting_unit.unit_index];
                if ( global.P_Turn.CO.COP_on ) fire_range += global.P_Turn.CO.COP_Rng[global.acting_unit.unit_index];
                if ( global.P_Turn.CO.SCOP_on ) fire_range += global.P_Turn.CO.SCOP_Rng[global.acting_unit.unit_index];
                
                if( scr_check_units_in_range( global.posX, global.posY, global.acting_unit.min_range, fire_range, false) )
                    {
                    //check if can Move fire
                    if(global.acting_unit.canMoveFire)
                        {    
                        global.engage = true;
                        global.engage_type = 1 ;
                        }
                    //check indirect fire only
                    else if ( !global.acting_unit_moved ) 
                        {
                        global.engage = true;
                        global.engage_type = 1 ;
                        }
                    }
                }
            }
        }
    
    //if items exsist, create syscom_command
    if( global.capture   
    or  global.engage       
    or  global.join         
    or  global.attach       
    or  global.supply       
    or  global.load         
    or  global.drop_A       
    or  global.drop_B       
    or  global.infiltrate   
    or  global.hide         
    or  global.appear       
    or  global.disrupt      
    or  global.wait
    //Special CO commands
    or  global.smoke)
        {
        //clear all checker graphics ( no sprite)
        with(obj_checker_tile) sprite_index = -1;
        //change sprite back at destination
        global.rangeCheck[global.posX,global.posY].sprite_index = spr_rangecheck_clear
    
        //deactivate move cursor object
        instance_deactivate_object(obj_moveCursorMouse);
        //create command menu    
        instance_create(x+24,y,obj_syscom_command);
        with( obj_syscom_command ) by_mouse = true; 
        }
    //no item exsist, reset
    else {
        global.wait = false;
        //exit move action (delet self and reactivate relevent elements)
        //clear move datea
        scr_rangeCheck_reset();
        //clear move order array
        ds_priority_clear(global.move_order);
        //destroy path nodes
        with(obj_path_node) instance_destroy();
       
        //place active unit back in array
        obj_map.units[global.acting_unit.x div 24,global.acting_unit.y div 24] = global.acting_unit
        global.acting_unit.state = "idle";
        scr_setUnitDepth(global.acting_unit);
        
         
    
        //reset path Q
        ds_priority_clear(global.move_order);
        
        //place acting unit back into array
     
        //reset global vunit command variables to default
        global.acting_unit  = 0;    //empty
        global.target_unit  = 0;    //empty
        global.action_order = "wait"; //default to wait
        
        //reactivate main phaze YI
        instance_activate_object(obj_battleCursor);
        instance_activate_object(obj_miniwin);
        //destroy move cursor
        with (obj_moveCursorMouse){instance_destroy();}
        
        //reset standing
        scr_updateStanding_global();
        //update Radio Boarder
        scr_globalRadioCheck();
        scr_update_radioBoarder();
        scr_rangeCheck_reset();
        }
    }
        
    







</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Debug
/*
draw_text( 12,12, string( global.rangeCheck[global.posX, global.posY].rb_edge));
draw_text( 12,24, string( global.rangeCheck[global.posX, global.posY].rb_corner));
draw_text( 12,36, string( global.rangeCheck[global.posX, global.posY].rb_fill_h));
draw_text( 12,48, string( global.rangeCheck[global.posX, global.posY].rb_fill_v));

//draw_text(12,48+12*2,"P2 CO Zone: " + string(global.rangeCheck[global.posX,global.posY].CO_Zone[2]));
//draw_text(12,48+12*3,"P4 CO Zone: " + string(global.rangeCheck[global.posX,global.posY].CO_Zone[4]));

//draw_text(12, 240, string(global.acting_unit.team) + "/" + string(global.acting_unit.ownership));
draw_text(12, 240, string(global.acting_unit.team) + ":" + string(global.acting_unit.name));
draw_text(12, 268, string(global.acting_unit.team) + ":" + string(obj_map.units[global.posX,global.posY]));



/*

draw_text(12,300, "movecost: " + string( global.rangeCheck[x div 24, y div 24].move_cost) + "/" +string(global.acting_unit.move_points));
draw_text(12,313, "terrain cost: " + string(scr_check_move_cost(global.acting_unit,obj_map.terrains[x div 24, y div 24])));


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw radio assist

if radio_assist_on
    {
    scr_draw_radioAssist(global.posX,global.posY,radioAssistRange,radioAssist_sprite);
    if (radioAssist_sprite = spr_radioAssist_darkBlue and global.cursorFrame = 2 ) draw_sprite(spr_Hazzard,0,x,y);
    }
    
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Move Left

if (  path_max - path_total &gt;= 0  and path_total !=0)
    {
    scr_draw_num( spr_num_outlined , false, path_max - path_total, x+21, y+3, 2 );    
    //scr_draw_num( spr_num_red, true, path_total, x, y, 3 );    
    
    //draw_set_color(c_black);
    //draw_text(x+1,y+1, string(path_total)); 
    //draw_text(x+1,y+1+12, string(global.acting_unit.move_points));
    
    //draw_set_color(c_orange);
    //draw_text(x,y, string(path_total)); 
    //draw_text(x,y+12, string(global.acting_unit.move_points));
    
    //draw_set_color(global.c_uiWhite);
    
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw self, special action cues, and radio assist
draw_self();

if (fire_range &gt; 1 and global.acting_unit.ammo &gt; 0 and global.acting_unit.canMoveFire) scr_draw_radioAssist(global.posX,global.posY,fire_range,spr_rangeAssist);
if (fire_range &gt; 1 and global.acting_unit.ammo &gt; 0 and global.indirect_assist_on ){ 
    scr_draw_radioAssist(global.posX,global.posY,fire_range,spr_rangeAssist);
    scr_draw_radioAssist(global.posX,global.posY,min_fire_range-1,spr_rangeAssist);
    }
if (obj_map.units[global.posX,global.posY] !=0 and global.rangeCheck[global.posX,global.posY].sprite_index = spr_rangecheck_clear)
    {
    if ((global.cursorFrame = 2 or global.cursorFrame = 1) and obj_map.units[global.posX,global.posY].team = global.P_Turn.team )
        {
        //join
        if (obj_map.units[global.posX,global.posY].hp &lt; 10 and obj_map.units[global.posX,global.posY].name = global.acting_unit.name and !global.acting_unit.dummy and global.target_unit.dummy) draw_sprite( spr_basicCursor_Icons,4,x,y); 
        //attach
        if ( obj_map.units[global.posX,global.posY].isCommander = false and global.acting_unit.canAttach and !global.acting_unit.dummy and global.target_unit.dummy) draw_sprite(spr_basicCursor_Icons,3,x,y);
        //Load
        if ( obj_map.units[global.posX,global.posY].canLoadInfantry and global.target_unit.dummy)
            {
            if (global.acting_unit.name = "long Gun" or global.acting_unit.name = "Light Infantry" or global.acting_unit.name = "Heavy Infantry") draw_sprite( spr_basicCursor_Icons,2,x,y);
            }                
        }
    }
    
//draw_text(x, y-24, "move cost"); 

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Mouse Pointer

draw_sprite(spr_mousePointer,global.P_Turn.number - 1, mouse_x, mouse_y);


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
